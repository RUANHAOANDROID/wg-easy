'use strict';

const fs = require('node:fs/promises');// 文件系统，支持Promise风格的API
const path = require('path'); // 用于处理文件路径
const debug = require('debug')('WireGuard');// 用于调试信息输出
const crypto = require('node:crypto'); // 提供加密功能
const QRCode = require('qrcode');// 用于生成二维码
const CRC32 = require('crc-32');// CRC32 校验库
// 导入自定义工具和错误模块
const Util = require('./Util');
const ServerError = require('./ServerError');
// 导入配置常量
const {
  WG_PATH, // WireGuard配置文件存储路径
  WG_HOST, // WireGuard服务器主机地址
  WG_PORT, // WireGuard监听端口
  WG_CONFIG_PORT, // WireGuard客户端配置端口
  WG_MTU, // MTU (最大传输单元)
  WG_DEFAULT_DNS, // 默认DNS服务器
  WG_DEFAULT_ADDRESS, // 默认地址格式
  WG_PERSISTENT_KEEPALIVE, // 持久化保持连接时间
  WG_ALLOWED_IPS, // 允许的IP地址
  WG_PRE_UP, // WireGuard启动前脚本
  WG_POST_UP, // WireGuard启动后脚本
  WG_PRE_DOWN, // WireGuard关闭前脚本
  WG_POST_DOWN, // WireGuard关闭后脚本
  WG_ENABLE_EXPIRES_TIME, // 是否启用客户端到期时间功能
  WG_ENABLE_ONE_TIME_LINKS, // 是否启用一次性链接功能
} = require('../config');

// WireGuard类定义，包含管理WireGuard配置和客户端的各种方法
module.exports = class WireGuard {
  // 内部方法，用于构建WireGuard配置文件
  async __buildConfig() {
    this.__configPromise = Promise.resolve().then(async () => {
      if (!WG_HOST) {
        throw new Error('WG_HOST Environment Variable Not Set!');// 如果没有设置WG_HOST，抛出错误
      }

      debug('Loading configuration...');
      let config;
      try {
        // 尝试从文件系统中读取现有配置
        config = await fs.readFile(path.join(WG_PATH, 'wg0.json'), 'utf8');
        config = JSON.parse(config);
        debug('Configuration loaded.');
      } catch (err) {
        // 如果配置文件不存在，生成一个新的配置
        const privateKey = await Util.exec('wg genkey'); // 生成私钥
        const publicKey = await Util.exec(`echo ${privateKey} | wg pubkey`, {
          log: 'echo ***hidden*** | wg pubkey',// 隐藏私钥
        });
        const address = WG_DEFAULT_ADDRESS.replace('x', '1');

        config = {
          server: {
            privateKey,
            publicKey,
            address,
          },
          clients: {},
        };
        debug('Configuration generated.');
      }

      return config;
    });

    return this.__configPromise;
  }

// 获取WireGuard配置，如果配置不存在则构建配置
  async getConfig() {
    if (!this.__configPromise) {
      const config = await this.__buildConfig();

      await this.__saveConfig(config);// 保存配置到文件
      await Util.exec('wg-quick down wg0').catch(() => {
      });// 尝试关闭现有的wg0接口
      await Util.exec('wg-quick up wg0').catch((err) => {
        if (err && err.message && err.message.includes('Cannot find device "wg0"')) {
          throw new Error('WireGuard exited with the error: Cannot find device "wg0"\nThis usually means that your host\'s kernel does not support WireGuard!');
        }

        throw err;
      });
      // await Util.exec(`iptables -t nat -A POSTROUTING -s ${WG_DEFAULT_ADDRESS.replace('x', '0')}/24 -o ' + WG_DEVICE + ' -j MASQUERADE`);
      // await Util.exec('iptables -A INPUT -p udp -m udp --dport 51820 -j ACCEPT');
      // await Util.exec('iptables -A FORWARD -i wg0 -j ACCEPT');
      // await Util.exec('iptables -A FORWARD -o wg0 -j ACCEPT');
      await this.__syncConfig();// 同步WireGuard配置
    }

    return this.__configPromise;
  }
  // 保存配置到文件并同步到WireGuard
  async saveConfig() {
    const config = await this.getConfig();
    await this.__saveConfig(config);
    await this.__syncConfig();
  }
  // 内部方法，用于将配置写入文件系统
  async __saveConfig(config) {
    let result = `
# Note: Do not edit this file directly.
# Your changes will be overwritten!

# Server
[Interface]
PrivateKey = ${config.server.privateKey}
Address = ${config.server.address}/24
ListenPort = ${WG_PORT}
PreUp = ${WG_PRE_UP}
PostUp = ${WG_POST_UP}
PreDown = ${WG_PRE_DOWN}
PostDown = ${WG_POST_DOWN}
`;

    for (const [clientId, client] of Object.entries(config.clients)) {
      if (!client.enabled) continue;

      result += `

# Client: ${client.name} (${clientId})
[Peer]
PublicKey = ${client.publicKey}
${client.preSharedKey ? `PresharedKey = ${client.preSharedKey}\n` : ''
      }AllowedIPs = ${client.address}/32`;
    }

    debug('Config saving...');
    await fs.writeFile(path.join(WG_PATH, 'wg0.json'), JSON.stringify(config, false, 2), {
      mode: 0o660,
    });
    await fs.writeFile(path.join(WG_PATH, 'wg0.conf'), result, {
      mode: 0o600,
    });
    debug('Config saved.');
  }
  // 内部方法，同步WireGuard配置到实际运行的wg0接口
  async __syncConfig() {
    debug('Config syncing...');
    await Util.exec('wg syncconf wg0 <(wg-quick strip wg0)');
    debug('Config synced.');
  }
  // 获取所有客户端信息
  async getClients() {
    const config = await this.getConfig();
    const clients = Object.entries(config.clients).map(([clientId, client]) => ({
      id: clientId,
      name: client.name,
      enabled: client.enabled,
      address: client.address,
      publicKey: client.publicKey,
      createdAt: new Date(client.createdAt),
      updatedAt: new Date(client.updatedAt),
      expiredAt: client.expiredAt !== null
        ? new Date(client.expiredAt)
        : null,
      allowedIPs: client.allowedIPs,
      oneTimeLink: client.oneTimeLink ?? null,
      oneTimeLinkExpiresAt: client.oneTimeLinkExpiresAt ?? null,
      downloadableConfig: 'privateKey' in client,
      persistentKeepalive: null,
      latestHandshakeAt: null,
      transferRx: null,
      transferTx: null,
      endpoint: null,
    }));
    // 从WireGuard状态中获取每个客户端的连接信息
    // Loop WireGuard status
    const dump = await Util.exec('wg show wg0 dump', {
      log: false,
    });
    dump
      .trim()
      .split('\n')
      .slice(1)
      .forEach((line) => {
        const [
          publicKey,
          preSharedKey, // eslint-disable-line no-unused-vars  未使用的预共享密钥
          endpoint, // eslint-disable-line no-unused-vars 未使用的端点
          allowedIps, // eslint-disable-line no-unused-vars 未使用的允许的IP地址
          latestHandshakeAt,
          transferRx,
          transferTx,
          persistentKeepalive,
        ] = line.split('\t');

        const client = clients.find((client) => client.publicKey === publicKey);
        if (!client) return;

        client.latestHandshakeAt = latestHandshakeAt === '0'
          ? null
          : new Date(Number(`${latestHandshakeAt}000`));
        client.endpoint = endpoint === '(none)' ? null : endpoint;
        client.transferRx = Number(transferRx);
        client.transferTx = Number(transferTx);
        client.persistentKeepalive = persistentKeepalive;
      });

    return clients;
  }
  // 获取特定客户端信息
  async getClient({clientId}) {
    const config = await this.getConfig();
    const client = config.clients[clientId];
    if (!client) {
      throw new ServerError(`Client Not Found: ${clientId}`, 404);
    }

    return client;
  }
  // 获取客户端的配置文件
  async getClientConfiguration({clientId}) {
    const config = await this.getConfig();
    const client = await this.getClient({clientId});

    return `
[Interface]
PrivateKey = ${client.privateKey ? `${client.privateKey}` : 'REPLACE_ME'}
Address = ${client.address}/24
${WG_DEFAULT_DNS ? `DNS = ${WG_DEFAULT_DNS}\n` : ''}\
${WG_MTU ? `MTU = ${WG_MTU}\n` : ''}\

[Peer]
PublicKey = ${config.server.publicKey}
${client.preSharedKey ? `PresharedKey = ${client.preSharedKey}\n` : ''
    }AllowedIPs = ${WG_ALLOWED_IPS}
PersistentKeepalive = ${WG_PERSISTENT_KEEPALIVE}
Endpoint = ${WG_HOST}:${WG_CONFIG_PORT}`;
  }
  // 获取客户端配置的二维码（SVG格式）
  async getClientQRCodeSVG({clientId}) {
    const config = await this.getClientConfiguration({clientId});
    return QRCode.toString(config, {
      type: 'svg',
      width: 512,
    });
  }
  // 创建新的客户端
  async createClient({name, expiredDate}) {
    if (!name) {
      throw new Error('Missing: Name');
    }

    const config = await this.getConfig();
    // 生成客户端的私钥和公钥
    const privateKey = await Util.exec('wg genkey');
    const publicKey = await Util.exec(`echo ${privateKey} | wg pubkey`, {
      log: 'echo ***hidden*** | wg pubkey',
    });
    const preSharedKey = await Util.exec('wg genpsk');

    // Calculate next IP  计算下一个可用的IP地址
    let address;
    for (let i = 2; i < 255; i++) {
      const client = Object.values(config.clients).find((client) => {
        return client.address === WG_DEFAULT_ADDRESS.replace('x', i);
      });

      if (!client) {
        address = WG_DEFAULT_ADDRESS.replace('x', i);
        break;
      }
    }

    if (!address) {
      throw new Error('Maximum number of clients reached.');
    }
    // Create Client 创建客户端信息
    const id = crypto.randomUUID();
    const client = {
      id,
      name,
      address,
      privateKey,
      publicKey,
      preSharedKey,

      createdAt: new Date(),
      updatedAt: new Date(),
      expiredAt: null,
      enabled: true,
    };
    if (expiredDate) {
      client.expiredAt = new Date(expiredDate);
      client.expiredAt.setHours(23);
      client.expiredAt.setMinutes(59);
      client.expiredAt.setSeconds(59);
    }
    config.clients[id] = client;

    await this.saveConfig();

    return client;
  }
  // 删除客户端
  async deleteClient({clientId}) {
    const config = await this.getConfig();

    if (config.clients[clientId]) {
      delete config.clients[clientId];
      await this.saveConfig();
    }
  }
  // 启用客户端
  async enableClient({clientId}) {
    const client = await this.getClient({clientId});

    client.enabled = true;
    client.updatedAt = new Date();

    await this.saveConfig();
  }
  // 生成一次性链接，用于客户端的临时访问
  async generateOneTimeLink({clientId}) {
    const client = await this.getClient({clientId});
    const key = `${clientId}-${Math.floor(Math.random() * 1000)}`;
    client.oneTimeLink = Math.abs(CRC32.str(key)).toString(16);
    client.oneTimeLinkExpiresAt = new Date(Date.now() + 5 * 60 * 1000);// 链接有效期为5分钟
    client.updatedAt = new Date();
    await this.saveConfig();
  }
// 清除一次性链接
  async eraseOneTimeLink({clientId}) {
    const client = await this.getClient({clientId});
    // client.oneTimeLink = null;
    client.oneTimeLinkExpiresAt = new Date(Date.now() + 10 * 1000);// 链接有效期为10秒
    client.updatedAt = new Date();
    await this.saveConfig();
  }
  // 禁用客户端
  async disableClient({clientId}) {
    const client = await this.getClient({clientId});

    client.enabled = false;
    client.updatedAt = new Date();

    await this.saveConfig();
  }
// 更新客户端名称
  async updateClientName({clientId, name}) {
    const client = await this.getClient({clientId});

    client.name = name;
    client.updatedAt = new Date();

    await this.saveConfig();
  }
  // 更新客户端的IP地址
  async updateClientAddress({clientId, address}) {
    const client = await this.getClient({clientId});

    if (!Util.isValidIPv4(address)) {
      throw new ServerError(`Invalid Address: ${address}`, 400);
    }

    client.address = address;
    client.updatedAt = new Date();

    await this.saveConfig();
  }
  // 更新客户端的到期时间
  async updateClientExpireDate({clientId, expireDate}) {
    const client = await this.getClient({clientId});

    if (expireDate) {
      client.expiredAt = new Date(expireDate);
      client.expiredAt.setHours(23);
      client.expiredAt.setMinutes(59);
      client.expiredAt.setSeconds(59);
    } else {
      client.expiredAt = null;
    }
    client.updatedAt = new Date();

    await this.saveConfig();
  }
  // 重载WireGuard配置
  async __reloadConfig() {
    await this.__buildConfig();
    await this.__syncConfig();
  }
  // 恢复WireGuard的配置
  async restoreConfiguration(config) {
    debug('Starting configuration restore process.');
    const _config = JSON.parse(config);
    await this.__saveConfig(_config);
    await this.__reloadConfig();
    debug('Configuration restore process completed.');
  }
  // 备份WireGuard配置
  async backupConfiguration() {
    debug('Starting configuration backup.');
    const config = await this.getConfig();
    const backup = JSON.stringify(config, null, 2);
    debug('Configuration backup completed.');
    return backup;
  }

  // Shutdown wireguard 关闭WireGuard服务
  async Shutdown() {
    await Util.exec('wg-quick down wg0').catch(() => {
    });
  }
  //每分钟执行的定时任务，处理客户端过期和一次性链接失效
  async cronJobEveryMinute() {
    const config = await this.getConfig();
    let needSaveConfig = false;
    // Expires Feature 处理客户端到期
    if (WG_ENABLE_EXPIRES_TIME === 'true') {
      for (const client of Object.values(config.clients)) {
        if (client.enabled !== true) continue;
        if (client.expiredAt !== null && new Date() > new Date(client.expiredAt)) {
          debug(`Client ${client.id} expired.`);
          needSaveConfig = true;
          client.enabled = false;
          client.updatedAt = new Date();
        }
      }
    }
    // One Time Link Feature  处理一次性链接失效
    if (WG_ENABLE_ONE_TIME_LINKS === 'true') {
      for (const client of Object.values(config.clients)) {
        if (client.oneTimeLink !== null && new Date() > new Date(client.oneTimeLinkExpiresAt)) {
          debug(`Client ${client.id} One Time Link expired.`);
          needSaveConfig = true;
          client.oneTimeLink = null;
          client.oneTimeLinkExpiresAt = null;
          client.updatedAt = new Date();
        }
      }
    }
    if (needSaveConfig) {
      await this.saveConfig();
    }
  }
  // 获取WireGuard的指标信息
  async getMetrics() {
    const clients = await this.getClients();
    let wireguardPeerCount = 0;
    let wireguardEnabledPeersCount = 0;
    let wireguardConnectedPeersCount = 0;
    let wireguardSentBytes = '';
    let wireguardReceivedBytes = '';
    let wireguardLatestHandshakeSeconds = '';
    for (const client of Object.values(clients)) {
      wireguardPeerCount++;
      if (client.enabled === true) {
        wireguardEnabledPeersCount++;
      }
      if (client.endpoint !== null) {
        wireguardConnectedPeersCount++;
      }
      wireguardSentBytes += `wireguard_sent_bytes{interface="wg0",enabled="${client.enabled}",address="${client.address}",name="${client.name}"} ${Number(client.transferTx)}\n`;
      wireguardReceivedBytes += `wireguard_received_bytes{interface="wg0",enabled="${client.enabled}",address="${client.address}",name="${client.name}"} ${Number(client.transferRx)}\n`;
      wireguardLatestHandshakeSeconds += `wireguard_latest_handshake_seconds{interface="wg0",enabled="${client.enabled}",address="${client.address}",name="${client.name}"} ${client.latestHandshakeAt ? (new Date().getTime() - new Date(client.latestHandshakeAt).getTime()) / 1000 : 0}\n`;
    }

    let returnText = '# HELP wg-easy and wireguard metrics\n';

    returnText += '\n# HELP wireguard_configured_peers\n';
    returnText += '# TYPE wireguard_configured_peers gauge\n';
    returnText += `wireguard_configured_peers{interface="wg0"} ${Number(wireguardPeerCount)}\n`;

    returnText += '\n# HELP wireguard_enabled_peers\n';
    returnText += '# TYPE wireguard_enabled_peers gauge\n';
    returnText += `wireguard_enabled_peers{interface="wg0"} ${Number(wireguardEnabledPeersCount)}\n`;

    returnText += '\n# HELP wireguard_connected_peers\n';
    returnText += '# TYPE wireguard_connected_peers gauge\n';
    returnText += `wireguard_connected_peers{interface="wg0"} ${Number(wireguardConnectedPeersCount)}\n`;

    returnText += '\n# HELP wireguard_sent_bytes Bytes sent to the peer\n';
    returnText += '# TYPE wireguard_sent_bytes counter\n';
    returnText += `${wireguardSentBytes}`;

    returnText += '\n# HELP wireguard_received_bytes Bytes received from the peer\n';
    returnText += '# TYPE wireguard_received_bytes counter\n';
    returnText += `${wireguardReceivedBytes}`;

    returnText += '\n# HELP wireguard_latest_handshake_seconds UNIX timestamp seconds of the last handshake\n';
    returnText += '# TYPE wireguard_latest_handshake_seconds gauge\n';
    returnText += `${wireguardLatestHandshakeSeconds}`;

    return returnText;
  }
 // 获取WireGuard的指标信息（JSON格式）
  async getMetricsJSON() {
    const clients = await this.getClients();
    let wireguardPeerCount = 0;
    let wireguardEnabledPeersCount = 0;
    let wireguardConnectedPeersCount = 0;
    for (const client of Object.values(clients)) {
      wireguardPeerCount++;
      if (client.enabled === true) {
        wireguardEnabledPeersCount++;
      }
      if (client.endpoint !== null) {
        wireguardConnectedPeersCount++;
      }
    }
    return {
      wireguard_configured_peers: Number(wireguardPeerCount),
      wireguard_enabled_peers: Number(wireguardEnabledPeersCount),
      wireguard_connected_peers: Number(wireguardConnectedPeersCount),
    };
  }

};
